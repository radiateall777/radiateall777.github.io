[{"title":"分支和循环","url":"/2023/02/09/%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF/","content":"\n分支语句主要包括两种\n\n\nif - else语句\n\n​\t\t注意：if-else语句默认只能控制一条语句；else的匹配是依据最近的if的匹配原则。\n\nswitch语句\n\nswitch(整形表达式)&#123;    case 整形常量表达式:    \t语句项；&#125;//注意break的使用\n\n\n\n\n循环语句主要是三种\n\n\nwhile循环\nfor循环\n\nfor（表达式1；表达式2；表达式3；）&#123;  循环语句；&#125;//表达式1:初始化部分，用于初始化值//表达式2：条件判断部分，用于判断循环何时终止//表达式3:调整部分，用于循环条件的调整for(;;)&#123;  printf(&quot;hehe&quot;);&#125;//此情况下判断条件恒为真，程序为死循环\n\n注意：不可在for循环体内改变循环变量，防止for循环失去控制；建议for语句的循环控制变量的取值采用“前闭后开”的写法。\nfor循环初始化、调整和判断都可以省略，但是，for循环的判断部分如果省略，那判断条件就恒为真。\n\ndo···while循环\n\n该情况下，循环语句至少执行一次。\n这里介绍两个关键字：break和continue。\nbreak：在循环中只要遇到break，就停止后面的所有循环，直接终止循环；\ncontinue：用于终止本次循环，也就是不再执行continue语句后面的代码，直接跳到循环的判断部分。\nwhile(i&lt;=10)&#123;  if(i == 5)    continue;//直接返回到循环的判断部分  printf(&quot;%d\\n&quot;,i);  i++;&#125;//程序进入死循环\n\n\n\n\ngetchar()与putchar()函数\n\nint ch = getchar();putchar(ch);while((ch = getchar()) != EOF)&#123;  putchar(ch);&#125;//EOF - end of file --- -1稳健的结束标志int ret = 0;char password[20] = &#123;0&#125;;scanf(&quot;%s&quot;,password);printf(&quot;请确认(y/n)：&gt;&quot;);ret = getchar();if(ret == &#x27;y&#x27;)&#123;  printf(&quot;确认成功\\n&quot;);&#125;else&#123;  printf(&quot;放弃确认\\n&quot;);&#125;//这段代码存在的问题是，字符串输入在缓存区中会以&#x27;\\0&#x27;为结束的标志位，所以getchar（）函数是从缓存区中读取读取所需要的内容，这样就使得getchar（）读取的内容为&#x27;\\n&#x27;,而不是y/n,此时代码就出现了问题。//对代码进行修正int ret = 0;char password[20] = &#123;0&#125;;scanf(&quot;%s&quot;,password);printf(&quot;请确认(y/n)：&gt;&quot;);while((ch = getchar()) != &#x27;\\n&#x27;)&#123;  ;&#125;//清空缓存区ret = getchar();if(ret == &#x27;y&#x27;)&#123;  printf(&quot;确认成功\\n&quot;);&#125;else&#123;  printf(&quot;放弃确认\\n&quot;);&#125;\n\n","tags":["C语言"]},{"title":"C语言中的函数","url":"/2023/02/17/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/","content":"\n函数定义\n\n\n在计算机科学中，子程序是一个大型程序中的某部分代码，由一个或者多个语句块组成，它负责完成某项特定任务，而且相对于其它代码具有相对独立性。\n\n对于函数，一般会有输入参数并有返回值，函数提供对于过程的封装和细节的隐藏，这些代码通常被集成为软件库。\n\nC语言常用的函数库\n\nIO函数\n\n字符串操作函数\n\n字符操作函数\n\n内存操作函数\n\n时间&#x2F;日期函数\n\n数学函数\n\n其它库函数\n\n\n\n自定义函数\n\n\n组成：\nret_type fun_name(para1 ,*)&#123;  statement;&#125;ret_type: 返回类型fun_name: 函数名paral: 函数参数//函数体交代函数是如何实现的\n\n\n\n\n函数的参数\n\n实际参数：真是传给函数的参数，叫实参；\n形式参数：函数名后的括号中的参数。\n当实参传给形参时，形参只是实参的一份临时拷贝，因此对于形参的修改并不会改变实参的实际值的大小。\n\n函数的调用\n\n传值调用：函数的实参和形参分别占用不同的内存块，对形参的修改不会影响到实参\n传址调用：把函数外部创建的变量的内存地址传递给函数的一种调用方式。\n\n这种方式可以让函数与函数外部的变量建立起真正的联系，也就是函数内部可以直接操作函数外部的变量。\n\n函数的声明和定义\n\n函数声明：告诉编译器有一个函数叫什么，参数是什么，返回类型是什么，但具体函数的实现是否存在无关紧要；函数声明一般出现在函数使用之前，要满足先声明后使用；函数声明一般放在头文件中。\n函数定义：指函数的具体实现，交代函数的功能。\n\n函数的定义和声明的使用分别放在.c和.h文件中。\n\n函数的递归\n\n\n​\t递归：函数调用自身的编程技巧称为递归。（递归的思想：把大师化小）。\n​\t递归的两个必要条件：\n\n存在限制条件，当满足这个条件时，递归不在继续。\n每次递归调用都要越来越接近这个限制条件。\n\n递归中需要注意的问题：栈溢出。\n//编写函数不允许创建临时变量，求字符串长度//利用递归调用的思想int my_strlen(int arr[])&#123;  if(*arr != &#x27;\\0&#x27;)&#123;    return my_strlen(str+1) + 1;  &#125;  else  \treturn 0;&#125;int main()&#123;  char arr[] = &quot;hello world&quot;;  int len = my_strlen(arr);  printf(&quot;%d&quot;,len);    return 0;&#125;\n\n\n\n//编写函数，求n的阶乘int fac(int n)&#123;  if(n&lt;=1)&#123;    return 1;  &#125;  else&#123;    return fac(n-1) * n ;  &#125;&#125;//编写函数，实现求解斐波那契数列int Fib(int n)&#123;  if(n&lt;=2)&#123;    return 1;  &#125;  else&#123;    return Fib(n-1)+Fib(n-2);  &#125;&#125;//需要注意的是，每一次递归的过程都会产生很大的空间浪费，因为递归会产生量的重复操作。//使用非递归的思想求解第n个斐波那契数int Fib(int n)&#123;  int a = 1;  int b = 1;  int c = 1;  while(n&gt;2)&#123;    c = a+b;    a = b;    b = c;    n--;  &#125;    return c;&#125;\n\n","tags":["C-语言"]},{"title":"分支和循环的练习","url":"/2023/02/12/%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%83%E4%B9%A0/","content":"\n编写代码计算n的阶乘\n\n#include &lt;stdio.h&gt;int main()&#123;  int n;  int i = 1;  int ret = 1;  scanf(&quot;%d&quot;,&amp;n);  for(i = 1; i&lt;=n; i++)&#123;    ret *= i;  &#125;    printf(&quot;%d\\n&quot;,ret);    return 0&#125;\n\n\n\n\n编写代码，计算1！+2！+···+10！\n\n#include &lt;stdio.h&gt;int main()&#123;  int n = 1;  int ret = 1;  for(n=1;n&lt;=10;n++)&#123;    for(int j = 1; j&lt;=i; j++)&#123;      ret *=j;    &#125;    sum = sum+ret;  &#125;    printf(&quot;%d\\n&quot;,sum);    return 0;&#125;//还可以对上述代码进行优化，减少重复的阶乘运算int main()&#123;  int i= 1;  int j= 1;  int ret = 1;  int sum = 0;    for(i = 1; i&lt;=10; i++)&#123;    ret = ret*i;    sum += ret;  &#125;    printf(&quot;%d&quot;,sum);    return 0;&#125;\n\n\n\n\n编写代码，可以在一个有序数组中查找一个具体的数字n，编写int binsearch(int x,int v[],int n),功能：v[0]&lt;&#x3D;v[1]&lt;&#x3D;v[2]&lt;&#x3D;···&lt;&#x3D;v[n-1]的数组中查找x。\n\n#include &lt;stdio.h&gt;int main()&#123;  int arr[] = &#123;1,2,3,4,5,6,7,8,9&#125;;  int k = 7;  int sz = sizeof(arr)/sizeof(arr[0]);    for(int i = 0; i&lt;sz ;i++)&#123;    if(arr[i] == k)&#123;      printf(&quot;下标是：%d&quot;,i);      break;    &#125;  &#125;  if(i == sz)&#123;    printf(&quot;search fail\\n&quot;);  &#125;    return 0;&#125;//采用函数的方法int binsearch(int x,int v[],int n)&#123;    for (int i = 0; i &lt; n; ++i) &#123;        if (x != v[i])            continue;    &#125;    if (i&gt;=n)        return 0;    else        return 1;&#125;int main()&#123;    int v[10] = &#123;0&#125;;    int x;    for (int j = 0; j &lt; 10; ++j) &#123;        scanf(&quot;%d&quot;,v[j]);    &#125;    scanf(&quot;%d\\n&quot;,&amp;x);    for (int i = 0; i &lt; 10; ++i) &#123;        if (binsearch(x,v[10],10) == 1)&#123;            printf(&quot;succes\\n&quot;);        &#125;        else            printf(&quot;fail\\n&quot;);    &#125;    return 0;&#125;\n\n\n\n\n编写代码，演示多个字符从两端移动向中间汇聚；\n\n#include &lt;stdio.h&gt;int main()&#123;  char arr1[] = &quot;welcome to bit!!!!!!&quot;;  char arr2[] = &quot;####################&quot;;    int left = 0;  int right = strlen(arr1)-1;  while(left &lt;= right)&#123;    arr2[left] = arr1[left];    arr2[right] = arr1[right];    printf(&quot;%s\\n&quot;,arr2);    left++;    right--;  &#125;    return 0;&#125;\n\n\n\n\n编写代码，使三个数从大到小输出\n\n#include &lt;stdio.h&gt;int main()&#123;  int x,y,z;  int temp;  scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);    if(x&lt;y)&#123;    temp = x;    x = y;    y = temp;  &#125;  if(x &lt; z)&#123;    temp = z;    x = z;    z = temp;  &#125;   if(y &lt; z)&#123;     temp = y;     y = z;     z = temp;  &#125;    printf(&quot;%d %d %d&quot;,x,y,z);    return 0;&#125;\n\n\n\n\n编写代码，模拟用户登陆场景，且只可登陆3次\n\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;  int i = 0;  char password[20];  for( i = 0; i&lt;3 ; ++i)&#123;    printf(&quot;请输入密码：&gt;&quot;);    scanf(&quot;%s\\n&quot;,password);    if(strcmp(password , &quot;123456&quot;) == 0)&#123;//strcmp函数用于比较两个字符串是否相等，切记字符串的比较不\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t可使用’==‘。      printf(&quot;success&quot;);      break;    &#125;  &#125;  if(i == 3)&#123;    printf(&quot;fail&quot;);  &#125;    return 0;&#125;\n\n\n\n","tags":["C-练习"]},{"title":"分支和循环练习","url":"/2023/02/13/%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"猜数字游戏\n\n电脑生成一个随机数\n猜数字\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;void menu()&#123;  printf(&quot;***********************\\n&quot;);  printf(&quot;****1.start   2.end****\\n&quot;);  printf(&quot;***********************\\n&quot;);&#125;void game()&#123;  int ret;  int guess;  ret = rand()%100 + 1;  while(1)&#123;    printf(&quot;请输入数字:&gt;&quot;);    scanf(&quot;%d&quot;,&amp;guess);    if(guess&gt;ret)&#123;      printf(&quot;猜大了\\n&quot;);    &#125;    else if(guess &lt; ret)&#123;      printf(&quot;猜小了\\n&quot;);    &#125;    else&#123;      printf(&quot;恭喜你，猜对了\\n&quot;);      break;    &#125;  &#125;&#125;int main()&#123;  int input;  srand((unsigned int)time(NULL));  do&#123;    menu();    scanf(&quot;%d&quot;,&amp;input);    switch(input)&#123;      case 0:        printf(&quot;退出游戏&quot;);        break;      case 1:        game();        break;      default:        printf(&quot;选择错误&quot;);        break;    &#125;  &#125;while(input);    return 0;&#125;\n\n","tags":["C-练习  猜数字游戏"]},{"title":"初识C语言（一）","url":"/2023/01/29/%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80/","content":"\n写C代码\n\nst=&gt;start: start op1=&gt;operation: Creat projectop2=&gt;operation: Creat fileop3=&gt;operation: Write source.fileop4=&gt;operation: Write codee=&gt;end: endst(right)-&gt;op1(right)-&gt;op2(right)-&gt;op3(right)-&gt;op4(right)-&gt;e\n\n\n数据类型\n\n\nchar\nshort\nint\nlong\nlong long\nfloat    ——单精度\ndouble   ——双精度\n\n为什么会有这么多类型？\n答：针对不同的数据大小所需要占用的内存，进行空间的分配有利于节省使用空间。\nsizeof（）函数作用：用于计算所申请的空间大小;\n计算机中的单位：bit——比特位  byte——字节\n#include&lt;stdio.h&gt;int main()&#123;\tprintf(&quot;%d\\n&quot;,sizeof(char));  return 0;&#125;\n\n\n变量和常量\n\n​\t变量的分类：局部变量和全局变量。\n\n局部变量：定义在代码块内部的变量\n全局变量：定义在代码块之外的变量\n\n#include &lt;studio.h&gt;//global var num1int num1 = 10;  int main()&#123;  //局部变量num2  int num2 = 10;  return 0;&#125;\n\n注意：C语言规定，变量要定义在输入代码块的最前面，否则代码执行时会报错。\n变量的类型不同，决定了它们具有不同的作用域和生命周期，对于局部变量，其作用域是变量所在的局部范围，生命周期则是进入作用域生命周期开始，出作用域生命周期结束；对于全局变量，其作用域是整个工程，生命周期是整个程序的生命周期。\n常量的类别：字面常量、用const修饰的常变量、#define定义的标识符常量、枚举常量（关键字enum）\n#include &lt;stdio.h&gt;enum Sex &#123;  MALE,FEMALE,SECRET&#125;;int main()&#123;  const int n=10; //使用const进行修饰，只是使变量n具有常属性，n仍然是变量  enum Sex s =FEMALE;//MALE，FEMALE，SECRET的值分别代表0，1，2；  return 0;&#125;\n\n\n\n\n字符串\n\n由双引号引起的一串字符串称为字符串字面值，其中空字符串也叫字符串。\n需要注意的是，字符串的结束标志是”\\0”的转义字符，在计算机计算字符串长度时，”\\0”是结束标志，但不算字符串中的内容。\nchar arr1[] = &quot;abc&quot;;//这种命名方式，会在字符串字符串结尾自动加上&quot;\\0&quot;的转义字符作为结束标志。同时该字符串长度为3.char arr2[] = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;//字符串arr2[]在计算字符串长度时会是一个随机值，因为计算机只有识别道转移字符&#x27;\\0&#x27;才会确定为字符串的结尾。\n\n\n转义字符\n\n转义字符即改变原来的意思,例如:”\\n”。\n\n选择语句\n\n常用的循环语句：\n\nwhile循环\nfor循环\ndo···while循环\n\n\n数组\n\n一组相同数据类型的变量集合。数组的下标是从0开始的。\nsizeof（）函数可以用来确定数组的大小。（所占用的字节大小）\n\n原码，反码，补码\n\n负数在二进制中存储时存储的是二进制的补码\n","tags":["C语言"]},{"title":"初识C语言（二）","url":"/2023/02/08/%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"\nC语言中常用的关键字\n\n\nregister关键字用来控制寄存器\n\n注意：在计算机中，数据存储在四个地方：寄存器、高速缓存、内存、硬盘\nregister int a =10;//这意味着建议把a定义成寄存器变量，注意这里是建议，具体要根据计算机程序设计的情况决定，由编译器进行判断是否将a定义成寄存器变量\n\n\ntypedy关键字—–类型重定义\n\ntypedef unsigned int u_int;//这样就把usigned int类型重定义成u_int类型，这样在定义usigned int 类型的变量时就可以使用u_int进行定义unsigned int num1;u_int num2;//以上两种定义方式等价\n\n注意：define不是关键字，它只是预处理指令。\n\nstatic关键字\n\n三个作用：\n（1）修饰局部变量，使局部变量的生命周期变长；\n（2）修饰全局变量，改变全局变量的作用域，使静态的全局变量只能在自己的所在的源文件内部使用，\t\t\t出除了源文件就没法使用了\n（3）修饰函数，改变函数的链接属性（外部链接属性——&gt;内部链接属性）\n\ndefine定义常量和宏\n\n#include &lt;stdio.h&gt;#define MAX 100 //#define定义的标识符常量int main()&#123;  int a = MAX;    return 0;&#125;\n\n//求所给两个数的最大值//1. 使用函数的方法#include &lt;stdio.h&gt;int Max(int x,int y)&#123;  if(x&gt;y)    return x;  else    return y;&#125;//2. 采用宏定义的方法#define MAX(X,Y) (X&gt;Y?X:Y)//优点是不用考虑数据类型了int main()&#123;  int a = 10;  int b = 20;    int max = Max(a,b);  printf(&quot;max = %d\\n&quot;,max);    max = MAX(a,b);  printf(&quot;max = %d\\n&quot;,max);    return 0;&#125;\n\n\n\n\n指针\n\n内存：内存是电脑中特别重要的存储器，计算机中所有程序都是在内存中运行的。\n","tags":["C语言"]},{"title":"数组-Array","url":"/2023/03/10/%E6%95%B0%E7%BB%84/","content":"\n数组的概念\n\n\n数组指的是一组相同类型元素的集合。（在这里的类型可以是C语言中内置的数据类型，如：int，float，double等，也可以是我们自定义的数据类型）\n\n\n一维数组的创建和初始化\n\n//创建方式 type_t arr_name[const_n]//type_t：指数组的类型//const_n：是一个常量表达式，用来指定数组的大小，注意不可使用变量\n\n\n\n\n数组的使用和存储\n\n\n数组使用下标来访问\n数组的大小可以通过计算来得到\n\n\n在计算机中，数组在内存中是连续存放的，定义数组时会在计算机内存中开辟一组连续的内存空间用来存储数组的数据元素。\n\n\n数组作为函数参数\n\n//冒泡排序函数将一个数组进行排序#include &lt;stdio.h&gt;void Bubble_sort(int arr[],int sz)&#123;    //实现冒泡排序    int temp = 0;    for(int i = 0; i&lt;sz-1 ;i++)&#123;        for(int j= 0;j&lt;sz-i-1;j++)&#123;            if(*(arr+j)&gt;*(arr+1+j))&#123;                temp = *(arr+j);                *(arr+j) = *(arr+1+j);                *(arr+1+j) = temp;            &#125;        &#125;    &#125;&#125;int main()&#123;    int arr[] = &#123;3,9,6,5,4,3,2,1&#125;;    int sz = sizeof(arr)/sizeof(arr[0]);    Bubble_sort(arr,sz);    for(int i = 0; i&lt;sz ; i++)&#123;        printf(&quot;%d &quot;,arr[i]);    &#125;    return 0;&#125;\n\n下面堆冒泡排序进行优化：\nvoid Bubble_sort(int arr,int sz)&#123;  //假设所给数组已经有序，如果采用上述算法，程序依然会执行for循环不断进行比较和交换  //这会导致没必要的浪费  int i = 0;  for(i = 0;i&lt;sz-1;i++)&#123;    int flag = 1;//假设这一次要排序的数据已经有序    int j = 0;    for(j = 0;j&lt;sz-1-i;j++)&#123;      if(arr[j]&gt;arr[j+1])&#123;        int temp = arr[j];        arr[j] = arr[j+1];        arr[j+1] = temp;        flag = 0;//本次循环排序数据不完全有序      &#125;    &#125;    if(flag == 1)&#123;      break;    &#125;  &#125;&#125;\n\n\n\n\n在大多数情况下，数组名等于首元素地址，当有两个例外情况：\n\n\nsizeof（数组名）此时数组名表示整个数组\n&amp;数组名，数组名指得是整个数组，&amp;数组名取出整个数组的地址\n\n数组地址不等于数组首元素地址。\n","tags":["C语言"]}]
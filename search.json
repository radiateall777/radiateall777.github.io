[{"title":"分支和循环","url":"/2023/02/09/%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF/","content":"\n分支语句主要包括两种\n\n\nif - else语句\n\n​\t\t注意：if-else语句默认只能控制一条语句；else的匹配是依据最近的if的匹配原则。\n\nswitch语句\n\nswitch(整形表达式)&#123;    case 整形常量表达式:    \t语句项；&#125;//注意break的使用\n\n\n\n\n循环语句主要是三种\n\n\nwhile循环\nfor循环\n\nfor（表达式1；表达式2；表达式3；）&#123;  循环语句；&#125;//表达式1:初始化部分，用于初始化值//表达式2：条件判断部分，用于判断循环何时终止//表达式3:调整部分，用于循环条件的调整for(;;)&#123;  printf(&quot;hehe&quot;);&#125;//此情况下判断条件恒为真，程序为死循环\n\n注意：不可在for循环体内改变循环变量，防止for循环失去控制；建议for语句的循环控制变量的取值采用“前闭后开”的写法。\nfor循环初始化、调整和判断都可以省略，但是，for循环的判断部分如果省略，那判断条件就恒为真。\n\ndo···while循环\n\n该情况下，循环语句至少执行一次。\n这里介绍两个关键字：break和continue。\nbreak：在循环中只要遇到break，就停止后面的所有循环，直接终止循环；\ncontinue：用于终止本次循环，也就是不再执行continue语句后面的代码，直接跳到循环的判断部分。\nwhile(i&lt;=10)&#123;  if(i == 5)    continue;//直接返回到循环的判断部分  printf(&quot;%d\\n&quot;,i);  i++;&#125;//程序进入死循环\n\n\n\n\ngetchar()与putchar()函数\n\nint ch = getchar();putchar(ch);while((ch = getchar()) != EOF)&#123;  putchar(ch);&#125;//EOF - end of file --- -1稳健的结束标志int ret = 0;char password[20] = &#123;0&#125;;scanf(&quot;%s&quot;,password);printf(&quot;请确认(y/n)：&gt;&quot;);ret = getchar();if(ret == &#x27;y&#x27;)&#123;  printf(&quot;确认成功\\n&quot;);&#125;else&#123;  printf(&quot;放弃确认\\n&quot;);&#125;//这段代码存在的问题是，字符串输入在缓存区中会以&#x27;\\0&#x27;为结束的标志位，所以getchar（）函数是从缓存区中读取读取所需要的内容，这样就使得getchar（）读取的内容为&#x27;\\n&#x27;,而不是y/n,此时代码就出现了问题。//对代码进行修正int ret = 0;char password[20] = &#123;0&#125;;scanf(&quot;%s&quot;,password);printf(&quot;请确认(y/n)：&gt;&quot;);while((ch = getchar()) != &#x27;\\n&#x27;)&#123;  ;&#125;//清空缓存区ret = getchar();if(ret == &#x27;y&#x27;)&#123;  printf(&quot;确认成功\\n&quot;);&#125;else&#123;  printf(&quot;放弃确认\\n&quot;);&#125;\n\n","tags":["C语言"]},{"title":"C语言中的函数","url":"/2023/02/17/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/","content":"\n函数定义\n\n\n在计算机科学中，子程序是一个大型程序中的某部分代码，由一个或者多个语句块组成，它负责完成某项特定任务，而且相对于其它代码具有相对独立性。\n\n对于函数，一般会有输入参数并有返回值，函数提供对于过程的封装和细节的隐藏，这些代码通常被集成为软件库。\n\nC语言常用的函数库\n\nIO函数\n\n字符串操作函数\n\n字符操作函数\n\n内存操作函数\n\n时间&#x2F;日期函数\n\n数学函数\n\n其它库函数\n\n\n\n自定义函数\n\n\n组成：\nret_type fun_name(para1 ,*)&#123;  statement;&#125;ret_type: 返回类型fun_name: 函数名paral: 函数参数//函数体交代函数是如何实现的\n\n\n\n\n函数的参数\n\n实际参数：真是传给函数的参数，叫实参；\n形式参数：函数名后的括号中的参数。\n当实参传给形参时，形参只是实参的一份临时拷贝，因此对于形参的修改并不会改变实参的实际值的大小。\n\n函数的调用\n\n传值调用：函数的实参和形参分别占用不同的内存块，对形参的修改不会影响到实参\n传址调用：把函数外部创建的变量的内存地址传递给函数的一种调用方式。\n\n这种方式可以让函数与函数外部的变量建立起真正的联系，也就是函数内部可以直接操作函数外部的变量。\n\n函数的声明和定义\n\n函数声明：告诉编译器有一个函数叫什么，参数是什么，返回类型是什么，但具体函数的实现是否存在无关紧要；函数声明一般出现在函数使用之前，要满足先声明后使用；函数声明一般放在头文件中。\n函数定义：指函数的具体实现，交代函数的功能。\n\n函数的定义和声明的使用分别放在.c和.h文件中。\n\n函数的递归\n\n\n​\t递归：函数调用自身的编程技巧称为递归。（递归的思想：把大师化小）。\n​\t递归的两个必要条件：\n\n存在限制条件，当满足这个条件时，递归不在继续。\n每次递归调用都要越来越接近这个限制条件。\n\n递归中需要注意的问题：栈溢出。\n//编写函数不允许创建临时变量，求字符串长度//利用递归调用的思想int my_strlen(int arr[])&#123;  if(*arr != &#x27;\\0&#x27;)&#123;    return my_strlen(str+1) + 1;  &#125;  else  \treturn 0;&#125;int main()&#123;  char arr[] = &quot;hello world&quot;;  int len = my_strlen(arr);  printf(&quot;%d&quot;,len);    return 0;&#125;\n\n\n\n//编写函数，求n的阶乘int fac(int n)&#123;  if(n&lt;=1)&#123;    return 1;  &#125;  else&#123;    return fac(n-1) * n ;  &#125;&#125;//编写函数，实现求解斐波那契数列int Fib(int n)&#123;  if(n&lt;=2)&#123;    return 1;  &#125;  else&#123;    return Fib(n-1)+Fib(n-2);  &#125;&#125;//需要注意的是，每一次递归的过程都会产生很大的空间浪费，因为递归会产生量的重复操作。//使用非递归的思想求解第n个斐波那契数int Fib(int n)&#123;  int a = 1;  int b = 1;  int c = 1;  while(n&gt;2)&#123;    c = a+b;    a = b;    b = c;    n--;  &#125;    return c;&#125;\n\n","tags":["C-语言"]},{"title":"分支和循环的练习","url":"/2023/02/12/%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%83%E4%B9%A0/","content":"\n编写代码计算n的阶乘\n\n#include &lt;stdio.h&gt;int main()&#123;  int n;  int i = 1;  int ret = 1;  scanf(&quot;%d&quot;,&amp;n);  for(i = 1; i&lt;=n; i++)&#123;    ret *= i;  &#125;    printf(&quot;%d\\n&quot;,ret);    return 0&#125;\n\n\n\n\n编写代码，计算1！+2！+···+10！\n\n#include &lt;stdio.h&gt;int main()&#123;  int n = 1;  int ret = 1;  for(n=1;n&lt;=10;n++)&#123;    for(int j = 1; j&lt;=i; j++)&#123;      ret *=j;    &#125;    sum = sum+ret;  &#125;    printf(&quot;%d\\n&quot;,sum);    return 0;&#125;//还可以对上述代码进行优化，减少重复的阶乘运算int main()&#123;  int i= 1;  int j= 1;  int ret = 1;  int sum = 0;    for(i = 1; i&lt;=10; i++)&#123;    ret = ret*i;    sum += ret;  &#125;    printf(&quot;%d&quot;,sum);    return 0;&#125;\n\n\n\n\n编写代码，可以在一个有序数组中查找一个具体的数字n，编写int binsearch(int x,int v[],int n),功能：v[0]&lt;&#x3D;v[1]&lt;&#x3D;v[2]&lt;&#x3D;···&lt;&#x3D;v[n-1]的数组中查找x。\n\n#include &lt;stdio.h&gt;int main()&#123;  int arr[] = &#123;1,2,3,4,5,6,7,8,9&#125;;  int k = 7;  int sz = sizeof(arr)/sizeof(arr[0]);    for(int i = 0; i&lt;sz ;i++)&#123;    if(arr[i] == k)&#123;      printf(&quot;下标是：%d&quot;,i);      break;    &#125;  &#125;  if(i == sz)&#123;    printf(&quot;search fail\\n&quot;);  &#125;    return 0;&#125;//采用函数的方法int binsearch(int x,int v[],int n)&#123;    for (int i = 0; i &lt; n; ++i) &#123;        if (x != v[i])            continue;    &#125;    if (i&gt;=n)        return 0;    else        return 1;&#125;int main()&#123;    int v[10] = &#123;0&#125;;    int x;    for (int j = 0; j &lt; 10; ++j) &#123;        scanf(&quot;%d&quot;,v[j]);    &#125;    scanf(&quot;%d\\n&quot;,&amp;x);    for (int i = 0; i &lt; 10; ++i) &#123;        if (binsearch(x,v[10],10) == 1)&#123;            printf(&quot;succes\\n&quot;);        &#125;        else            printf(&quot;fail\\n&quot;);    &#125;    return 0;&#125;\n\n\n\n\n编写代码，演示多个字符从两端移动向中间汇聚；\n\n#include &lt;stdio.h&gt;int main()&#123;  char arr1[] = &quot;welcome to bit!!!!!!&quot;;  char arr2[] = &quot;####################&quot;;    int left = 0;  int right = strlen(arr1)-1;  while(left &lt;= right)&#123;    arr2[left] = arr1[left];    arr2[right] = arr1[right];    printf(&quot;%s\\n&quot;,arr2);    left++;    right--;  &#125;    return 0;&#125;\n\n\n\n\n编写代码，使三个数从大到小输出\n\n#include &lt;stdio.h&gt;int main()&#123;  int x,y,z;  int temp;  scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);    if(x&lt;y)&#123;    temp = x;    x = y;    y = temp;  &#125;  if(x &lt; z)&#123;    temp = z;    x = z;    z = temp;  &#125;   if(y &lt; z)&#123;     temp = y;     y = z;     z = temp;  &#125;    printf(&quot;%d %d %d&quot;,x,y,z);    return 0;&#125;\n\n\n\n\n编写代码，模拟用户登陆场景，且只可登陆3次\n\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;  int i = 0;  char password[20];  for( i = 0; i&lt;3 ; ++i)&#123;    printf(&quot;请输入密码：&gt;&quot;);    scanf(&quot;%s\\n&quot;,password);    if(strcmp(password , &quot;123456&quot;) == 0)&#123;//strcmp函数用于比较两个字符串是否相等，切记字符串的比较不\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t可使用’==‘。      printf(&quot;success&quot;);      break;    &#125;  &#125;  if(i == 3)&#123;    printf(&quot;fail&quot;);  &#125;    return 0;&#125;\n\n\n\n","tags":["C-练习"]},{"title":"分支和循环练习","url":"/2023/02/13/%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"猜数字游戏\n\n电脑生成一个随机数\n猜数字\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;void menu()&#123;  printf(&quot;***********************\\n&quot;);  printf(&quot;****1.start   2.end****\\n&quot;);  printf(&quot;***********************\\n&quot;);&#125;void game()&#123;  int ret;  int guess;  ret = rand()%100 + 1;  while(1)&#123;    printf(&quot;请输入数字:&gt;&quot;);    scanf(&quot;%d&quot;,&amp;guess);    if(guess&gt;ret)&#123;      printf(&quot;猜大了\\n&quot;);    &#125;    else if(guess &lt; ret)&#123;      printf(&quot;猜小了\\n&quot;);    &#125;    else&#123;      printf(&quot;恭喜你，猜对了\\n&quot;);      break;    &#125;  &#125;&#125;int main()&#123;  int input;  srand((unsigned int)time(NULL));  do&#123;    menu();    scanf(&quot;%d&quot;,&amp;input);    switch(input)&#123;      case 0:        printf(&quot;退出游戏&quot;);        break;      case 1:        game();        break;      default:        printf(&quot;选择错误&quot;);        break;    &#125;  &#125;while(input);    return 0;&#125;\n\n","tags":["C-练习  猜数字游戏"]},{"title":"初识C语言（一）","url":"/2023/01/29/%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80/","content":"\n写C代码\n\nst=&gt;start: start op1=&gt;operation: Creat projectop2=&gt;operation: Creat fileop3=&gt;operation: Write source.fileop4=&gt;operation: Write codee=&gt;end: endst(right)-&gt;op1(right)-&gt;op2(right)-&gt;op3(right)-&gt;op4(right)-&gt;e\n\n\n数据类型\n\n\nchar\nshort\nint\nlong\nlong long\nfloat    ——单精度\ndouble   ——双精度\n\n为什么会有这么多类型？\n答：针对不同的数据大小所需要占用的内存，进行空间的分配有利于节省使用空间。\nsizeof（）函数作用：用于计算所申请的空间大小;\n计算机中的单位：bit——比特位  byte——字节\n#include&lt;stdio.h&gt;int main()&#123;\tprintf(&quot;%d\\n&quot;,sizeof(char));  return 0;&#125;\n\n\n变量和常量\n\n​\t变量的分类：局部变量和全局变量。\n\n局部变量：定义在代码块内部的变量\n全局变量：定义在代码块之外的变量\n\n#include &lt;studio.h&gt;//global var num1int num1 = 10;  int main()&#123;  //局部变量num2  int num2 = 10;  return 0;&#125;\n\n注意：C语言规定，变量要定义在输入代码块的最前面，否则代码执行时会报错。\n变量的类型不同，决定了它们具有不同的作用域和生命周期，对于局部变量，其作用域是变量所在的局部范围，生命周期则是进入作用域生命周期开始，出作用域生命周期结束；对于全局变量，其作用域是整个工程，生命周期是整个程序的生命周期。\n常量的类别：字面常量、用const修饰的常变量、#define定义的标识符常量、枚举常量（关键字enum）\n#include &lt;stdio.h&gt;enum Sex &#123;  MALE,FEMALE,SECRET&#125;;int main()&#123;  const int n=10; //使用const进行修饰，只是使变量n具有常属性，n仍然是变量  enum Sex s =FEMALE;//MALE，FEMALE，SECRET的值分别代表0，1，2；  return 0;&#125;\n\n\n\n\n字符串\n\n由双引号引起的一串字符串称为字符串字面值，其中空字符串也叫字符串。\n需要注意的是，字符串的结束标志是”\\0”的转义字符，在计算机计算字符串长度时，”\\0”是结束标志，但不算字符串中的内容。\nchar arr1[] = &quot;abc&quot;;//这种命名方式，会在字符串字符串结尾自动加上&quot;\\0&quot;的转义字符作为结束标志。同时该字符串长度为3.char arr2[] = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;//字符串arr2[]在计算字符串长度时会是一个随机值，因为计算机只有识别道转移字符&#x27;\\0&#x27;才会确定为字符串的结尾。\n\n\n转义字符\n\n转义字符即改变原来的意思,例如:”\\n”。\n\n选择语句\n\n常用的循环语句：\n\nwhile循环\nfor循环\ndo···while循环\n\n\n数组\n\n一组相同数据类型的变量集合。数组的下标是从0开始的。\nsizeof（）函数可以用来确定数组的大小。（所占用的字节大小）\n\n原码，反码，补码\n\n负数在二进制中存储时存储的是二进制的补码\n","tags":["C语言"]},{"title":"初识C语言（二）","url":"/2023/02/08/%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"\nC语言中常用的关键字\n\n\nregister关键字用来控制寄存器\n\n注意：在计算机中，数据存储在四个地方：寄存器、高速缓存、内存、硬盘\nregister int a =10;//这意味着建议把a定义成寄存器变量，注意这里是建议，具体要根据计算机程序设计的情况决定，由编译器进行判断是否将a定义成寄存器变量\n\n\ntypedy关键字—–类型重定义\n\ntypedef unsigned int u_int;//这样就把usigned int类型重定义成u_int类型，这样在定义usigned int 类型的变量时就可以使用u_int进行定义unsigned int num1;u_int num2;//以上两种定义方式等价\n\n注意：define不是关键字，它只是预处理指令。\n\nstatic关键字\n\n三个作用：\n（1）修饰局部变量，使局部变量的生命周期变长；\n（2）修饰全局变量，改变全局变量的作用域，使静态的全局变量只能在自己的所在的源文件内部使用，\t\t\t出除了源文件就没法使用了\n（3）修饰函数，改变函数的链接属性（外部链接属性——&gt;内部链接属性）\n\ndefine定义常量和宏\n\n#include &lt;stdio.h&gt;#define MAX 100 //#define定义的标识符常量int main()&#123;  int a = MAX;    return 0;&#125;\n\n//求所给两个数的最大值//1. 使用函数的方法#include &lt;stdio.h&gt;int Max(int x,int y)&#123;  if(x&gt;y)    return x;  else    return y;&#125;//2. 采用宏定义的方法#define MAX(X,Y) (X&gt;Y?X:Y)//优点是不用考虑数据类型了int main()&#123;  int a = 10;  int b = 20;    int max = Max(a,b);  printf(&quot;max = %d\\n&quot;,max);    max = MAX(a,b);  printf(&quot;max = %d\\n&quot;,max);    return 0;&#125;\n\n\n\n\n指针\n\n内存：内存是电脑中特别重要的存储器，计算机中所有程序都是在内存中运行的。\n","tags":["C语言"]},{"title":"数组-Array","url":"/2023/03/10/%E6%95%B0%E7%BB%84/","content":"\n数组的概念\n\n\n数组指的是一组相同类型元素的集合。（在这里的类型可以是C语言中内置的数据类型，如：int，float，double等，也可以是我们自定义的数据类型）\n\n\n一维数组的创建和初始化\n\n//创建方式 type_t arr_name[const_n]//type_t：指数组的类型//const_n：是一个常量表达式，用来指定数组的大小，注意不可使用变量\n\n\n\n\n数组的使用和存储\n\n\n数组使用下标来访问\n数组的大小可以通过计算来得到\n\n\n在计算机中，数组在内存中是连续存放的，定义数组时会在计算机内存中开辟一组连续的内存空间用来存储数组的数据元素。\n\n\n数组作为函数参数\n\n//冒泡排序函数将一个数组进行排序#include &lt;stdio.h&gt;void Bubble_sort(int arr[],int sz)&#123;    //实现冒泡排序    int temp = 0;    for(int i = 0; i&lt;sz-1 ;i++)&#123;        for(int j= 0;j&lt;sz-i-1;j++)&#123;            if(*(arr+j)&gt;*(arr+1+j))&#123;                temp = *(arr+j);                *(arr+j) = *(arr+1+j);                *(arr+1+j) = temp;            &#125;        &#125;    &#125;&#125;int main()&#123;    int arr[] = &#123;3,9,6,5,4,3,2,1&#125;;    int sz = sizeof(arr)/sizeof(arr[0]);    Bubble_sort(arr,sz);    for(int i = 0; i&lt;sz ; i++)&#123;        printf(&quot;%d &quot;,arr[i]);    &#125;    return 0;&#125;\n\n下面堆冒泡排序进行优化：\nvoid Bubble_sort(int arr,int sz)&#123;  //假设所给数组已经有序，如果采用上述算法，程序依然会执行for循环不断进行比较和交换  //这会导致没必要的浪费  int i = 0;  for(i = 0;i&lt;sz-1;i++)&#123;    int flag = 1;//假设这一次要排序的数据已经有序    int j = 0;    for(j = 0;j&lt;sz-1-i;j++)&#123;      if(arr[j]&gt;arr[j+1])&#123;        int temp = arr[j];        arr[j] = arr[j+1];        arr[j+1] = temp;        flag = 0;//本次循环排序数据不完全有序      &#125;    &#125;    if(flag == 1)&#123;      break;    &#125;  &#125;&#125;\n\n\n\n\n在大多数情况下，数组名等于首元素地址，当有两个例外情况：\n\n\nsizeof（数组名）此时数组名表示整个数组\n&amp;数组名，数组名指得是整个数组，&amp;数组名取出整个数组的地址\n\n数组地址不等于数组首元素地址。\n","tags":["C语言"]},{"title":"三字棋","url":"/2023/03/11/%E4%B8%89%E5%AD%90%E6%A3%8B11/","content":"用C语言实现一个三子棋小游戏：\n//编写主函数#include &quot;game.h&quot;void menu()&#123;  printf(&quot;*************************&quot;);  printf(&quot;**1. 开始游戏  2. 退出游戏**&quot;);  printf(&quot;*************************&quot;);&#125;//游戏的整个算法实现void game()&#123;  char ret = 0;  //数组走出的棋盘信息  char board[ROW][COL] = &#123;0&#125;;  //初始化棋盘  InitBoard(board,ROW,COL);  //打印棋盘  DisplayBoard(board,ROW,COL);  //开始下棋  while(1)&#123;    //玩家下棋    PlayerMove(board,ROW,COL);    DisplayBoard(board,ROW,COL);    //判断玩家是否赢    ret = IsWin(board,ROW,COL);    if(ret != &#x27;C&#x27;)&#123;      break;    &#125;    //电脑下棋    ComputerMove(board,ROW,COL);    DisplayBoard(board,ROW,COL);    //判断电脑是否赢    ret = IsWin(board,ROW,COL);    if(ret != &#x27;C&#x27;)&#123;      break;    &#125;  &#125;&#125;int main()&#123;  int input;  //已知游戏最少玩一次  do&#123;    menu();    printf(&quot;请选择：&gt;&quot;);    scanf(&quot;%d&quot;,&amp;input);    switch(input)&#123;      case 1:        game();        break;      case 0:        printf(&quot;退出游戏：&quot;);        break;      default:        printf(&quot;选择错误，请重新选择：&gt;&quot;);        break;    &#125;while(input);  &#125;&#125;\n\n\n\n接下来在game.h文件中定义和声明整个游戏实现所需要常量的定义和函数声明：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define ROW 3#define COL 3//函数声明void InitBoard(char board[ROW][COL],int row,int col);void DisplayBoard(char board[ROW][COL],int row,int col);void PlayerMove(char board[ROW][COL],int row,int col);void ComputerMove(char board[ROW][COL],int row,int col);//告诉我们四种状态//玩家赢 - ‘*’//电脑赢 - ‘#’//平局 - ‘Q’//继续 - ‘C&#x27;char IsWin(char board[ROW][COL],int row,int col);\n\n\n\n接下来在game.c文件中实现在game.h文件中声明的函数：\n#include &quot;game.h&quot;void InitBoard(char board[ROW][COL],int row,int col)&#123;  int i = 0;  int j = 0;  for(i = 0; i&lt;row; ++i)&#123;    for(j = 0;j&lt;col; ++j)&#123;      board[i][j] = &#x27; &#x27;;    &#125;  &#125;&#125;void DisplayBoard(char board[ROW][COL],int row,int col)&#123;  int i = 0;  int j = 0;  for(i = 0; i&lt;row; i++)&#123;    for(j = 0; j&lt;col; j++)&#123;      printf(&quot; %c &quot;,board[i][j]);      if(j&lt;col-1)        printf(&quot;|&quot;);    &#125;    printf(&quot;\\n&quot;);    //打印分割行    if(i &lt; row -1)&#123;      for( j = 0; j&lt;col ; ++j)&#123;        printf(&quot;---&quot;);        if(j &lt; col-1)          printf(&quot;|&quot;);      &#125;      printf(&quot;\\n&quot;);    &#125;  &#125;&#125;void PlayerMove(char board[ROW][COL],int row,int col)&#123;  int x = 0;  int y = 0;  printf(&quot;玩家走：&gt;&quot;);  while(1)&#123;    printf(&quot;请输入坐标：&gt;&quot;);    scanf(&quot;%d%d&quot;,&amp;x,&amp;y);    //判断坐标的合法性    if(x&gt;=1 &amp;&amp; x&lt;=row &amp;&amp; y&gt;= 1 &amp;&amp; y&lt;= col)&#123;      if(board[x-1][y-1] == &#x27; &#x27;)&#123;        board[x-1][y-1] = &#x27;*&#x27;;        break;      &#125;      else        printf(&quot;该坐标被占用\\n&quot;);    &#125;    else      printf(&quot;请输入合法坐标\\n&quot;);  &#125;&#125;void ComputerMove(char board[ROW][COL],int row,int col)&#123;  int x = 0;  int y = 0;  printf(&quot;电脑走：&gt;\\n&quot;);  while(1)&#123;    x = rand()%row;    y = rand()%col;    if(board[x][y] == &#x27; &#x27;)&#123;      board[x][y] = &#x27;#&#x27;;      break;    &#125;  &#125;&#125;//检查棋盘是否已满//返回1，表示棋盘满了；返回0，表示棋盘未满；int IsFull(char board[ROW][COL],int row,int col)&#123;  int i = 0;  int j = 0;  for(i = 0; i &lt; row; ++i)&#123;    for(j = 0; j &lt; col; ++j)&#123;      if(board[i][j] == &#x27; &#x27;)&#123;        return 0;      &#125;    &#125;  &#125;  return 1;&#125;void ComputerMove(char board[ROW][COL],int row,int col)&#123;  int i = 0;  //检查横三行  for(i = 0 ;i &lt; row; ++i)&#123;    if(board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2]&amp;&amp; board[i][1] != &#x27; &#x27;)&#123;      return board[i][1];    &#125;  &#125;  //检查竖三列  for(i = 0; i &lt; col; ++i)&#123;    if(board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i]&amp;&amp; board[i][1] != &#x27; &#x27;)&#123;      return board[1][i];    &#125;  &#125;  //检查对角线  if(board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2]&amp;&amp; board[1][1] != &#x27; &#x27;)&#123;      return board[1][1];  &#125;    if(board[0][2] == board[1][1] &amp;&amp; board[1][1] == board[2][0]&amp;&amp; board[1][1] != &#x27; &#x27;)&#123;      return board[1][1];  &#125;    //判断是否平局  if(1 == IsFull(board,ROW,COL))&#123;    return &#x27;Q&#x27;;  &#125;    return &#x27;C&#x27;;&#125;\n\n","tags":["C语言"]},{"title":"操作符详解","url":"/2023/03/11/%E6%93%8D%E4%BD%9C%E7%AC%A6/","content":"\n操作符的分类\n\n算术操作符（+，-，*，&#x2F;，%）；\n\n移位操作符（&lt;&lt; 左移操作符    &gt;&gt; 右移操作符）\n\n位操作符（&amp;，^，｜）\n\n单目操作符（sizeof（））\n\n关系操作符（&#x3D;&#x3D;，&gt;&#x3D;，&lt;&#x3D;，！&#x3D;，&gt;，&lt;）\n\n逻辑操作符（&amp;&amp;，||）\n\n条件操作符（exp？exp1：exp2；）\n\n赋值操作符\n\n\n\n移位操作符详解\n\n\n​\t移位操作符主要包含两种移位方式：\n\n算术右移：右边丢弃左边补原符号位（普遍）\n逻辑右移：右边丢弃，左边补零\n\n\n整数的二进制表示有：原码，反码，补码\n整数在计算机中主要是以补码的方式进行存储的，对于正整数而言，其原，反，补是相同的，但是对于负整数而言则不一样。\n\n例如：负整数 -1\n原码：10000000000000000000000000000001\n反码：11111111111111111111111111111110\n补码：11111111111111111111111111111111\n\n&amp;，｜，^操作符的含义\n\n​\t这三种操作符都是位操作符，只作用于整数；\n​\t&amp; ——按位与（2进制位）\n​\t｜——按位或（2进制位）\n​\t^ ——按位异或（2进制位）相同为0，不同为1\n//位操作符具有非常实际的应用//例如：交换A和B的值//要求：不允许创建临时变量//方法1:#include &lt;stdio.h&gt;int main()&#123;  int A = 9;  int B = 10;  //加减法  A = A + B;  B = A - B;  A = A - B;    return 0;&#125;//利用加减法进行这种交换存在问题，那就是A+B可能会产生溢出//方法2:#include &lt;stdio.h&gt;int main()&#123;  int a = 10;  int b = 9;  //异或法  a = a^b;  b = a^b;  a = a^b;    return 0;&#125;\n\n\n\n//编写代码，求一个整数在内存中二进制位中1的个数//方法1:#include &lt;stdio.h&gt;int main()&#123;    int n;    int count = 0;    scanf(&quot;%d&quot;,&amp;n);    //(unsigned int)n;    unsigned int m = (unsigned int)n;    while(m != 0)&#123;        if((m%2) == 1)&#123;            count++;        &#125;        m = m/2;    &#125;    printf(&quot;%d&quot;,count);    return 0;&#125;//方法2:#include &lt;stdio.h&gt;int main()&#123;    int num;    int count = 0;    scanf(&quot;%d&quot;,&amp;num);    //利用位操作符进行计算    for(int i = 0; i&lt;32 ; i++)&#123;        if(1 == ((num&gt;&gt;i)&amp;1))&#123;            count++;        &#125;        //num&gt;&gt;i;    &#125;    printf(&quot;%d&quot;,count);    return 0;&#125;\n\n\n\n\n单目操作符的几个特例\n\n\nsizeof()操作符\n\n\nSizeof()操作符为单目操作符，用于计算变量所占内存空间的大小（单位为字节）\n\nint arr[10];//去掉数组名剩下的就是数组类型short s = 0;int a = 10;printf(&quot;%d&quot;,sizeof(s=a+5));//结果为2printf(&quot;%d&quot;,s);//结果为0//造成上述现象的原因是在sizeof（s = a+5）的括号中表达式并不会真正的参与运算\n\n\n～按位取反\n\n\n&amp;&amp;，||逻辑操作符的含义\n\n&amp;&amp;：只要左边算出了假，后面的代码将不再执行\n||：只要左边算出了真，后面的代码将不再执行\n\n\n逗号表达式\n\n\n\n逗号表达式：从左到右依次执行，整个表达式的结果是左后一个表达式的结果；\n\n\n隐式类型转换\n\n​\tC的整形运算总是至少以缺省整型类型的精度来进行的，为提高精度，表达式中字符和短整型操作数在使用之前变为普通整型，这种转换成为整型提升。\n注意：整型提升是按照变量的数据类型的符号位进行提升的。\nchar a = 3;//二进制为：00000011\t\t\t\t\t//整型提升以后：00000000 00000000 00000000 00000011char b = 127;//二进制为：01111111\t\t\t\t\t\t//整型提升以后：00000000 00000000 00000000 01111111char c = a+b; //10000010  - printf(&quot;%d&quot;,c); //11111111 11111111 11111111 10000010 - 补码\t\t\t\t\t\t\t\t//11111111 11111111 11111111 10000001 - 反码\t\t\t\t\t\t\t\t//10000000 00000000 00000000 01111110 - 原码 - -126\n\n\n\n//整型提升：int main()&#123;  char a = 0xb6;  short b = 0xb600;  int c = 0xb6000000;    if(a == 0xb6)    printf(&quot;a&quot;);  if(b == 0xb600)    printf(&quot;b&quot;);  if(c == 0xb6000000)    printf(&quot;c&quot;);    return 0;&#125;//注意“==”比较操作符也相当于运算，需要进行整型提升，因此本题结果只打印‘c’\n\n","tags":["C语言"]},{"title":"指针初阶","url":"/2023/03/12/%E6%8C%87%E9%92%88/","content":"\n指针的概念\n\n\n在计算机科学中，指针（pointer）是编程语言中的一个对象，利用地址，他的值直接指向存在电脑存储器中另一个地方的值，由于通过地址可以找到所需的变量单元，可以说指针指向该变量单元。因此，将地址形象化为指针。（即通过它可以找到以它为地址的内存单元。\n\n简单来说，指针是个变量，用来存放内存的地址\n\n指针类型\n\n\n指针类型决定了，指针在解引用操作时，所能访问的空间大小\n决定了指针+ - 整数时，指针的步长\n\n野指针概念：野指针就是指针变量指向的位置是未知的。（局部的指针变量未初始化就被初始化为一个随机值，这样做是有很大问题的）。\n指针一定要进行初始化\n规避野指针的方法：\n\n指针初始化\n小心指针越界\n指针指向空间释放，将指针置为空可以保留该指针\n指针使用之前必须检验指针的有效性\n\n\n指针运算\n\n//指针加减整数//指针减指针得到中间元素的个数arr[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;printf(&quot;%d&quot;,&amp;arr[9]-&amp;arr[0]);//打印中间元素的个数：9//使用指针模拟strlen函数的实现int my_strlen(char *arr)&#123;  //int count = 0;  char* start = arr;  char* end = arr;  while(*arr != &#x27;\\0&#x27;)&#123;    end++;  &#125;  return end - start;&#125;\n\n\n\n\n指针和数组\n\n在前面学习中其实已经讨论过，在大多数情况下，数组名表示首元素的地址，但是有两种例外情况：\n\nsizeof（数组名）这里的数组名表示整个数组，此时计算整个数组所占内存空间的大小。\n&amp;数组名，这时数组名表示的是整个数组的地址，而不是首元素的地址。\n\nint arr[10] = &#123;0&#125;;printf(&quot;%p\\n&quot;,arr);//此时数组名表示首元素的地址printf(&quot;%p\\n&quot;,&amp;arr[0]);//这种情况和上面等价，表示首元素的地址printf(&quot;%p\\n&quot;,&amp;arr);//此时数组名表示整个数组的地址，虽然在值上与上面两种情况相同，但它们的含义已经不一样了\n\n\n\n","tags":["C语言"]},{"title":"数据的存储","url":"/2023/03/13/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/","content":"数据类型的介绍在C语言中数据类型主要包括：内置类型和自定义类型。\n数据类型具有非常实际的意义，根据数据类型可以确定所开辟的空间的大小。\n\n类型的归类\n\n整型家族：char、int、short、long\n浮点型家族：float、double\n\n\n构造类型\n\n数组类型\n结构体类型（struct）\n枚举类型（enum）\n联合类型（union）\n\n\n\n\n空类型的定义：void表示空类型（无类型），通常应用于函数的返回类型，函数的参数，指针类型。\n\n整型在内存中的存储1. 原码、反码、补码的概念+ 原码：直接将整数按照二进制的形式进行翻译即可\n+ 反码：原码的符号位不变，其它位按位取反\n+ 补码：反码+1就是补码\n\n无符号原、反、补相同\n2. 大小端存储模式+ 大端存储模式：指数据的低位保存在内存中的高地址中，而数据的高位，保存在内存中的低地址处；\n+ 小端存储模式：指数据的低位保存在内存中的低地址中，而数据的高位，保存在内存中的高地址处。\n\n\n之所以有大小端模式之分，是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8个bit。但在C语言中还存在着除了8bit的char类型之外的16bit的short类型和32bit的long类型，另外，对于位数大于8bit的处理器，由于寄存器的宽度大于1个字节，那么必然存在着一个问题，如何将多个字节安排的问题。因此就导致了大小端存储模式的产生。\n\n浮点型在内存中的存储任意一个二进制浮点数v可以表示成下面的形式\n(-1)^s*M*2^E;//(-1)^表示符号位，当s = 0时，V为正数；当s = 1时，V为负数；//M表示有效数字，大于等于1，小于2；（因为二进制只有0和1；//2^E表示指数位例如：十进制5.0，写成二进制位101.0，相当于1.01*2^2;按照上面多给的格式可知：s = 0；M = 1.01；E = 2；\n\n\n对于32位浮点数，最高1位表示符号位，接着8位表示指数E，剩下23位表示有效数字M\n对于64位浮点数，最高1位表示符号位，接着11位表示指数E，剩下52位表示有效数字M\n\n\n由于1&lt;&#x3D;M&lt;2，也就是数M可以写成1.#####的形式，‘ ##### ’表示小数部分，在计算机内存内部保存M时，默认这个数的第一位总是1，因此可以被抹去，只保留后面的小数部分\n\nE为一个无符号整数，所以负数次方要加入一个中间值转化为无符号\n5.5 -----&gt; 二进制为：101.1  -----&gt; 1.011*2^2  ------&gt; (-1)^0*1.011*2^2;s = 0  ;   M = 1.011  ;  E = 2;——&gt; 0 10000001 01100000000000000000000;——&gt; 40 b0 00 00 十六进制\n\n\n\n\n\n","tags":["C语言"]},{"title":"指针详解","url":"/2023/03/16/%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6/","content":"常用的指针类型及概念\n字符指针：char*\n\n指针数组：指针数组是数组，它的元素类型是指针。\nint* parr[4];//存放整型指针的数组char* arr2[4];//存放字符指针的数组char** arr3[5]; //二级字符指针的数组\n\n数组指针：数组指针是指针，该指针指向一个数组，存放数组的地址。\nint arr[10] = &#123;0&#125;;//arr - 首元素的地址//&amp;arr[0] - 首元素的地址//&amp;arr - 数组的地址//例子1.int arr[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;int (*pa)[10] = &amp;arr;//定义了一个指针pa，指向一个数组，数组中有10个元素每个元素是int类型的//例子2.int *pa2[10];//pa2是一个数组，数组有10个元素，数组的每一个元素是一个int类型的指针//例子3.int (*pa3[10])[5];//pa3是一个数组，数组有10个元素，每个元素是一个数组指针，该数组指针指向一个含有5个元素的数组，该数组的每个元素是int类型的\n\n\n\n函数指针：指向函数的指针\n\n\n​\t&amp;函数名和函数名都是函数的地址，这点与数组是不同的\n//函数指针的声明int (*pa)(int , int);//pa是一个指针，该指针指向一个函数，该函数有两个int类型的参数，返回值是int//例子：(*(void(*)())0)();//这里是一次函数的调用//(void(*)()-函数的指针类型，放在0前把0强制转换成函数指针类型，接着调用0地址处的该函数\n\n\n函数指针数组\nint (*parr[4])(int , int);//parr是一个含有4个元素的数组，每个元素是一个函数指针，该函数指针所指向的函数含有两个int类型的参数，返回值是int类型的。\n\n​\t函数指针可以被用于：转移表。\n\n指向函数指针数组的指针：这是一个指针，该指针指向一个函数指针数组，该数组的每一个元素是一个函数指针。\n\n回调函数\n回调函数就是通过函数指针调用的函数，如果你把函数的指针（地址），作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数值，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的时间或条件发生时，由另外的一方调用的，用于对该事件或条件的响应。\n\n了解void* 指针void* 所定义的指针可以接收任意类型的指针，但需要注意的是，不可对该类型的指针进行解引用操作，因为void*类型的指针并没有规定其所能访问的字节数目，所以它也不能用于’ + ‘ ‘ - ‘整数的操作。\nqsort函数的实现可以有利于我们对函数指针有更为清晰的认识。\n","tags":["C语言"]},{"title":"python基础知识","url":"/2023/04/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"数据结构\n数据结构是以某种方式组合起来的数据元素，在python中最基础的数据结构是序列（sequence），序列中的每个元素都有编号，即其位置或索引。\n\n序列概述python中内置了多种序列，最常用的两种是：列表和元组。\n注意：这两种序列之间的区别是，列表是可以修改的，但是元组是不可以修改的，他们分别对应于不同的使用场景，多数情况下都可以使用列表来代替元组，但是有一种例外的情况是将元组用作字典键，因为字典键是不可以修改的。\n\npython支持一种数据结构的基本概念，名为容器（container）。容器基本上就是可包含其他对象的对象，两种主要的容器就是序列（列表和元组）和映射（字典），在序列中每个元素都是有编号的，而在字典中每个元素都是有名称的。有一种既不是序列也不是映射的容器是集合（set）\n\n通用的序列操作适用于所有序列的操作有：索引、切片、相加、相乘和成员资格检查。\n\n索引\n\n​\t序列中的所有元素都有编号——从0开始递增。你可以使用索引来获取元素，这种索引方式适用于所有序列，当使用负数索引时，python将从右开始往左数，所以-1是最后一个元素的位置。\n​\t对于字符串常量，可直接对其进行索引操作，不用先将其赋值给变量。这与先赋值给变量后进行索引的效果是一样的。\n\n切片\n\n​\t使用切片（slicing）可以访问特定范围内的元素。因此切片适用提取于提取序列的一部分。第一个索引是包含的第一个元素的编号，第二个是切片后余下的第一个元素的编号。（也就是说：第一个索引指定的的元素包含在切片内，但第二个索引指定的元素不包含在切片内。\n\n序列相加\n乘法\n成员资格\n\n​\t检查特定值是否在序列中使用运算符in\n列表：python的主力列表方法：\n\n方法是是对象联系紧密的函数：object.method(arguments)。方法调用和函数调用很相似，只是方法调用在前面加上了对象和句点。\n\n\nappend\n\n​\t方法append用于将一个对象附加到列表末尾\n\nclear\n\n​\t方法clear用于清空列表\n\ncopy\n\n​\t方法copy用于复制列表\n\ncount\n\n​\t计算指定元素在列表中出现了几次\n\nextend\n\n​\t方法extend可以附加多个值在末尾，为此可以用一个列表扩展另一个列表\n\nindex\n\n​\t方法index用于查找指定值第一次出现时的索引\n\ninsert\n\n​\t方法insert用于将一个对象插入列表\n\npop\n\n​\t方法pop从列表中删除一个元素（末尾为最后一个元素），并返回这个元素。\n\nremove\n\n​\t方法remove用于删除第一个为指定值的元素\n\nreverse\n\n​\t方法reverse按相反的顺序排列列表中的元素\n\nsort\n\n​\t方法sort用于对列表就地排序\n​\t\n","tags":["python"]},{"title":"string","url":"/2023/04/10/string/","content":"注意：字符串是不可变的，所有的元素赋值和切片赋值都是非法的。\n设置格式字符串在格式字符串中，最重要的是替换字段。替换字段由如下部分组成，其中每个部分都是可选的：\n\n字段名：索引或标识符，指出要设置哪个值的格式并使用结果来替换该字段。除指定值外，还可指定值的特定部分，如列表中的元素\n转换标志：跟在叹号后面的一个单个字符。当前支持的字符包括r（表示repr）、s（表示str）和a（表示ascii）。如果你指定了转换标志，将不使用对象本身的格式设置机制，而是使用指定的函数将对象转化为字符串，再做进一步的格式设置。\n格式说明符：跟在冒号后面的表达式（这种表示是使用微型格式指定语言表示的）。格式说明符让我们能够详细地指定最终的格式，包括格式类型（如字符串、浮点数或十六进制数），字段宽度和数的精度，如何显示符号和千位分隔符，以及各种对其和填充方式\n\n\n替换字段名\n\n&quot;&#123;foo&#125; &#123;&#125; &#123;bar&#125; &#123;&#125;&quot;.format(1, 2, bar = 4, foo =3)#结果：‘3 1 4 2’&quot;&#123;foo&#125; &#123;0&#125; &#123;bar&#125; &#123;1&#125;&quot;.format(1, 2, bar = 4, foo = 3)#结果： ‘3 1 2 4’\n\n注意：不可以同时使用自动编号和人工编号，这样会使代码变得混乱\nfullname = [&quot;Alfred&quot;,&quot;Smooktomuch&quot;]&quot;Mr &#123;name[1]&#125;&quot;.fomat&#123;name = fullname&#125;#结果：&#x27;Mr Sooktomuch&#x27;tmpl = &quot;The &#123;mod.__name__&#125; module defines the value &#123;mod.pi&#125; for pi&quot;tmpl.format(mod = math)#结果：&#x27;The math module defines the value 3.141592653589793 for pi&#x27;\n\n\n\n\n基本转换\n\n符号、对齐和用0填充\n\n\n字符串方法\ncenter\n\n#方法center通过两边填充字符（默认为空格）让字符串居中&#x27;the middle by Jimmy Eat world&#x27;,center(39)#结果：&#x27; The Middle by Jimmy Eat World &#x27;\n\n\nfind\n\n#反法find在字符串中查找字串。如果找到，就返回字串的第一个字符的索引，否则就返回-1&#x27;with a moo-moo here, and a moo-moo there&#x27;.find(&#x27;moo&#x27;)结果：7\n\n\njoin\n\n#方法join用于合并序列的元素seq = [1 ,2 ,3 , 4 ,5]sep = &#x27;+&#x27;sep.join(seq)#这样做是错误的，因为方法join所合并序列的元素必须是字符串\n\n\nlower\n\n​\t方法lower用于返回字符串的小写版本。\n\nreplace\n\n#方法replace将指定子串都替换为另一个字符串，并返回替换后的结果&#x27;This is a test&#x27;.replace(&#x27;is&#x27;,&#x27;eez&#x27;)\n\n\nsplit\n\n​\t方法split作用于join相反，用于将字符串拆分为序列。\n\nstrip\n\n#方法strip将字符串开头与末尾的空白删除，并返回删除后的结果&#x27;     internal whitespace is kept.    &#x27;.strip#结果：&#x27;internal whitespace is kept.&#x27;\n\n\ntranslate\n\n#方法translate与replace一样替换字符串的特定部分，但不同的是它只能进行单字符替换这个方法的优势是能进行多个字符的替换\n\n","tags":["python"]},{"title":"字典","url":"/2023/04/10/%E5%AD%97%E5%85%B8/","content":"python中的字典\n用途\n\n表示棋盘的状态，其中的每个键都是由坐标组成的元组\n存储文件修改时间，其中的键为文件名\n数字电话&#x2F;地址薄\n\n\n\n\n创建和使用字典\n\n​\t字典以下面形式表示：\nphonebook = &#123;&#x27;Alice&#x27;: &#x27;2314&#x27;,&#x27;Beth&#x27;: &#x27;9102&#x27;, &#x27;Cecil&#x27;: &#x27;3258&#x27;&#125;\n\n\n字典由键及其相应的值组成的，这种键-值对称为项（item），每个键与其值之间都用：分隔开，项之间用‘，’分割开，整个字典放在{}中。\n\n注意：在字典中，键必须是独一无二的，而字典中的值无需如此。\n\n函数dict\n\n​\t函数dict从其它映射或键-值对序列创建字典。\nitems = [(&#x27;name&#x27;, &#x27;Gumby&#x27;), (&#x27;age&#x27;, 42)]d = dict(items)d#结果：&#123;&#x27;age&#x27;: 42, &#x27;name&#x27;: &#x27;Gumby&#x27;&#125;d[&#x27;name&#x27;] #结果：&#x27;Gumby&#x27;\n\n\n\n\n基本的字典操作    + len（d）返回字典d包含的项（键-值对）数    + d[k]返回与键k相关联的值    + d[k] &#x3D; v将值v关联到键k    + del d[k]删除键为k的项    + k in d检查字典d是否包含键为k的项\n键的类型：字典中的键可以是整数，但并非必须是整数。字典中的键可以是任何不可变的类型，如浮点数、字符串或元组。\n自动添加：即便是是字典中原本没有的键，也可以给他赋值，这将在字典中创建一个新项。然而，如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值\n成员资格：表达式k in d（其中d是一个字典）查找的是键而不是值，而表达式v in l（其中l是一个列表）查找的是值而不是索引。\n\n\n将字符串格式设置功能用于字典\n\n字典方法\nclear\n\n​\t字典中的方法clear删除所有的字典项，这种方法是就地执行的，因此什么都不会返回。\n\ncopy\n\n​\t方法copy返回一个新字典，其包含的键值对与原来的字典相同（这种方法执行的是浅复制，因为值本身是原件，而不是副本）。\n注意：当替换副本中的值时，原件不受影响。然而如果修改副本中的值，原件也将发生变化，因为原件指向的也是被修改的值。\n\nfromkeys\n\n​\t方法formkeys创建一个新字典，其中包含指定的键，且每个键对应的值都是none。\n\nget\n\n​\t方法get为访问字典项提供了宽松的环境。通常，如果你尝试访问字典中没有的项，将会引发错误\n\nItems\n\n​\t方法items返回返回一个包含所有字典项的列表，其中每个元素都是（key，value）的形式。返回值属于一种名为字典视图的特殊类型。\n\nkeys\n\n​\t方法keys返回一个字典视图，其中包含指定字典的键\n\npop\n\n​\t方法pop用于获取与指定键相关联的值，并将该键-值对从字典中删除。\n\nPopitem\n\n​\t方法popitem类似于list.pop，list.pop弹出列表的最后一个元素，而popitem随机的弹出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素的”概念。\n\nsetdefault\n\n​\t方法setdefault有点像get，因为他也获取与指定键值相关联的值，但除此之外，setdefault还在字典中不包含指定的键时，添加指定的键-值对。\n\nupdate\n\n​\t方法update使用一个字典中的项更新另一个字典。对于通过参数提供的字典，将其项添加到当前字典中，如果当前字典包含键相同的项，就替换他。\n","tags":["python"]},{"title":"抽象","url":"/2023/04/11/%E6%8A%BD%E8%B1%A1/","content":"\n抽象就是如何将语句组成函数，这样可以简化代码的书写，实现同样的功能时，只需要调用一次函数就可以了，这与C语言中的函数是相似的概念。\n\n抽象和结构抽象可以节省人力，最重要的优点是：抽象是程序能够被人理解的关键。函数其实就是结构化编程的核心。\n自定义函数\n给函数编写文档\n\n​\t要给函数编写文档，以确保其他人能够理解，可添加注释。放在函数开头的字符串称为文档字符串，这将作为函数的一部分存储起来，这种给编写注释的方式非常有利于更好的理解函数的作用。\n\n其实并不是函数的函数\n\n​\t数学中的函数总是返回根据参数计算得到的结果。在python中有些函数什么都不返回，这样的函数称为过程，什么都不返回的函数不包含return语句，或者包含return语句，但没有在return后面指定值。\n参数魔法\n值从哪里来\n\n​\t在def语句中，位于函数名后面的变量通常称为形参，而调用函数时提供的参数称为实参。\n\n可以修改参数吗\n\n​\t函数通过参数获取一系列值，参数不过是变量而已，行为完全与你预期相同，在函数内部给参数赋值对外部没有任何影响。\n\n为何要修改参数\t\n在提高程序的抽象程度方面，使用函数来修改数据结构是一种不错的方式。\n\n\n\n关键字参数和默认值\n\n\n注意:通常不应结合使用位置参数和关键字参数，除非必不可少的参数很少，而带默认值的可选参数很多，否则不应结合使用关键字参数和位置参数。\n\n\n收集参数\n\n对象魔法\n对象意味着一系列数据以及一套访问和操作这些数据的方法。\n\n使用对象的好处\n\n多态：可对不同的对象执行相同的操作，而这些操作就像“被施了魔法“一样能够正常运行\n封装：对外部隐藏有关对象工作原理的细节\n继承：可基于通用类创建专用类\n\n\n多态\n\n​\t多态（polymorphism），这大致意味着即便你不知道变量指向的是哪种对象，也能对其进行操作，且操作的行为将随对象所属的类型而异。\n\n多态和方法\n\n\n与对象属性相关的联的函数称为方法。每当无需知道对象是什么样的就能对其执行操作时，都是多态在起作用。\n\n\n封装\n\n​\t封装（encapsulation）指的是向外部隐藏不必要的细节。\n注意：封装和多态虽然很相似，但是，封装不同于多态。多态让你无需知道对象所属的类就能调用其方法，而封装让你无需知道对象的构造就能使用它。\n\n继承\n\n​\t\n类\n类——一种对象。每个对象都属于特定的类，并被称为该累的实例。\n\n在面向对象编程中，子类关系更加以为深长，因为类是由其支持的方法定义的。类的所有实例都有该类的所有方法，因此子类的多有实例都有超类的所有方法。因此，要定义子类，只需要定义多余出来的方法（或重写一些既有的方法）。\n\n创建自定义类\n\nclass Person:    def set_name(self,name):    self.name = name     def get_name(self):    return self.name    def greet(self):    print(&quot;hello world! I&#x27;m &#123;&#125;&quot;.format(self.name))\n\n\n\n\n属性、函数和方法\n\n方法和函数的区别体现在前面提到的参数self上。方法（更准确的说是关联的方法）将其第一个参数关联到它所属的实例，因此无需提供这个参数。\n\n再谈隐藏\n\n类的命名空间\n\n\n在class语句中定义的代码都是在一个特殊的命名空间（类的命名空间）内执行的，而类的所有成员都可以访问这个命名空间。\n\n指定超类\n\nclass Filter:  def init(self):    self.blocked = []  def filter(self,sequence):    return [x for x in sequence if x not in self.blocked]    class SPAMFilter(Filter):\t\t\t#SPAMFilter是Filter的子类  def init(self):\t\t\t\t\t\t\t#重写超类Filter的方法init    self.blocked = [&#x27;SPAM&#x27;]\n\n\n\n\n接口和内省\n\n\n接口这一概念与多态相关，处理多态对象时，你只关心其接口——对外暴露的方法和属性。\n\n\n抽象基类\n\n\n一般而言，抽象类是不能实例化的类，其职责是定义子类应实现的一组抽象方法。\n\n","tags":["python"]},{"title":"Git使用手册","url":"/2023/04/06/Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","content":"Git介绍\nGit是一个免费的、开源的分布式版本控制系统，可以快速的处理从小型到大型的各种项目。\n\n何为版本控制版本控制是一种用于记录文件内容变化，以便将来查阅特定版本修订情况的系统。\n版本控制最重要的是可以记录文件修改历史记录，从而使用户可以看到历史版本方便版本切换。\n为什么需要版本控制个人开发过渡到团队协作（多副本的方式是有很大缺陷的，很容易导致两个人的代码相互覆盖）\n版本控制工具\n集中式的版本控制工具\n\n\n像CVS、SVN（Subversion）、VSS······这一类的软件属于集中式的版本控制工具。这些都有一个单一的集中管理的服务器，保存所有文件的修订版本，协同工作的人们通过客户端连接到这台服务器，取出最新的文件或者提交更新。\n\n\n分布式版本控制工具\n\n\n像git这一类的分布式版本控制工具，客户段提取的不是最新版本的文件快照，而是把代码仓库完整的镜像下来(本地库)。这样任何一处协同工作用的文件发生故障时，事后都可以用对其他客户端的本地仓库进行恢复，因为每个客户端的每次文件提取操作，实际上都是对整个文件仓库的完整备份。\n\n优点：\n\n服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）\n每个客户端保存的也都是整个完整的项目（包含历史记录，这样更加安全）\n\n\nGit工作机制\nGit和代码托管中心\n代码托管中心是基于网络服务器的远程代码仓库，一般我们称为远程库。\n\n\n局域网\nGitlab\n\n\n互联网\nGitHub（外网）\nGitee码云（国内网站）\n\n\n\nGit常用命令\n设置用户签名git config –global user.name 用户名。 设置用户签名\ngit config –global user.email 邮箱。     设置用户签名\n注意：\n\n签名的作用是区分不同的操作者身份。用户的签名信息在每个版本的提交信息中都能查看得到，以此确认本次提交是谁做的。Git首次安装必须设置一下用户签名，否则无法提交代码。\n这里设置的用户签名与将来登陆github的账号没有任何关系。\n\n版本号的穿梭git reset –hard 要穿梭的版本号\nGit 分支操作\n\n什么是分支\n\n​\t在版本控制过程中，同时推送多个任务，为每个任务，我们就可以创建每个任务单独的分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候不会影响主线分支的运行。分支可以简单的理解为一个副本，一个分支就是一个单独的副本。（分支底层实际上也是指针的引用）\n\n分支的操作\n\n\n查看分支\n创建分支\n切换分支\n把指定的分支合并到当前开发的分支上\n\n\n\n注意：\n\n冲突合并：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法帮我们决定使用哪个。必须人为决定新代码的内容。\n\nGit团队协作机制\n团队内协作\n\n\n\n跨团队协作\n\n\n​\t\nGitHub操作\n创建远程仓库 —— New Repository\n\n​\t\t注意：远程库和本地库的名字最好保持一致\n\n远程仓库操作\n\n\n+ 拉取远程库到本地库\n\n​\t基本语法：git pull 远程仓库别名 远程分支名\n​\t一定要保证本地库的代码与远程库是同步状态，要及时更新自己的本地库代码。\n+ 克隆远程仓库到本地库\n\n​\t基本语法：\tgit clone 远程地址\n​\t三件事：1）拉取代码 \t2）初始化本地仓库 \t3）创建别名\n+ Git_GitHub_团队内协作\n\n​\t在需要团队协作的库中，点击collaborators下的Mannge access邀请团队协作的成员\n+ Git_GitHub_跨团队协作\n\n​\t首先需要先进行fork，叉一份到你的仓库，然后克隆到本地库进行修改，或者直接进行修改，修改好以后，需要点击pull request创建一个pull request请求，发送给开发者。\t\n+ Git_GitHub_ssh免密登陆\n\n​\t远程仓库一般有一个SSH地址，因此我们可以使用SSH进行访问\n​\t首先运行命令生成.ssh密钥目录：使用 ssh-keygen -t rsa -C 账号邮箱（rsa是一种非对称形式的加密协议）\n​\t**Mac上使用shirt + command + .**显示隐藏的文件\n​\t打开生成的.ssh目下的pub文件会看到一个公共密钥\nIdea集成Git\n配置一个Git的忽略文件\n\n​\t原因：所忽略的文件与项目的实际功能无关，不参与服务器上部署运行。把他们忽略掉可以屏蔽IDE工具之间的\t差异。\n​\t方法：创建忽略规则文件xxxx.ignore(前缀名可以随便起，建议是git.ignore)\n​\t这个文件原则上放在什么地方都可以，但为了便于～&#x2F;.ignore文件引用，建议也放在用户家目录下。\n\n\nIdea中集成GitHub使用token进行登陆，在GitHub中点击settings在开发人员设置中的personal access tokens中生成一个登陆口令，权限全部给满。\n\n注意，push是将本地代码推送到远程库，如果本地代码与远程库代码不一致，push的操作会被拒绝，也就是说，要想push成功，一定要保证本地库的版本要比远程库的高。因此在动手改代码之前，一定要先检查本地库代码与远程库代码的区别，如果本地代码版本落后，就需要首先pull拉取远程库的代码，将本地代码更新到最新后，然后再修改提交推送。\n\n自建代码托管平台-GitLab","tags":["git"]},{"title":"异常","url":"/2023/04/13/%E5%BC%82%E5%B8%B8/","content":"异常是什么\npython中使用异常对象来表示异常状态，并在遇到错误时引发异常。异常对象未被处理（捕获）时，程序将终止并显示一条错误信息（traceback）。\n\n让事情沿你指定的轨道出错\nraise语句\n\n​\t要引发异常，可使用raise语句，并将一个类（必须是Exception的子类）或实例作为参数。将类作为参数时，将自动创建一个实例。\nraise Exception\n\n\n\n捕获异常x = int(input(&#x27;Enter the first number: &#x27;))y = int(input(&#x27;Enter the second number: &#x27;))print(x/y)#这个程序会在用户输入第二个数为0时出现异常，为捕获这种异常并对这种异常进行处理可重新上面程序try:  x = int(input(&#x27;Enter the first number: &#x27;))\ty = int(input(&#x27;Enter the second number: &#x27;))\tprint(x/y)except ZeroDivisionError:  print(&quot;The second number can&#x27;t be zero&quot;)  \n\n注意：异常从函数向外传播到调用函数的地方。如果异常没有被捕获，异常将向程序的最顶层传播，这意味着你可以使用try&#x2F;except来捕获所编写函数引发的异常。\n\n不用提供参数\n\n​\t捕获异常后，如果要重新引发他，可调用raise且不用提供任何参数（也可显式提供捕获到的异常）。\nclass MuffledCalculator:  muffled = False  del calc(self,expr):    try:      return eval(expr)    except ZeroDivisionError:      if self.muffled:        print(&#x27;Division by zero is illegal&#x27;)      else:        raise#发生除0行为时，如果启用了抑制功能，方法calc将隐式的返回None。换而言之如果启用了抑制功能，也不应依赖返回值。\n\n\n\n","tags":["python"]}]